#include <RGSL/packager.h>
#include <RGSL/termio.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdint.h>

static const struct stage_mapping STAGE_MAPPINGS[] = {
    {"vert", "RGSL_VERTEX"},
    {"frag", "RGSL_FRAGMENT"},
    {"comp", "RGSL_COMPUTE"}
};

void write_embedded_spirv(FILE *output_file, const uint32_t* spirv_words, size_t word_count) {
    fprintf(output_file, "\t{\n\t\t");
    for (size_t i = 0, j = 1; i < word_count; i++, j++) {
        fprintf(output_file, "0x%08X", spirv_words[i]);
        if (i < word_count - 1) {
            if (j == 10) {
                fprintf(output_file, ",\n\t\t");
                j = 0;
            } else {
                fprintf(output_file, ", ");
            }
        } else {
            fprintf(output_file, "\n");
        }
    }
    fprintf(output_file, "\t};\n");
}

void write_embedded_glsl(FILE *output_file, const char* glsl_code) {
    const char* ptr = glsl_code;
    fprintf(output_file, "\t\t\"");
    for (;*ptr != '\0'; ptr++) {
        if (*ptr == '\n') {
            fprintf(output_file, "\\n\"\n\t\t\"");
        } else if (*ptr == '\r') {
            continue; // Skip carriage returns
        } else if (*ptr == '\"') {
            fprintf(output_file, "\\\"");
        } else if (*ptr == '\\') {
            fprintf(output_file, "\\\\");
        } else {
            fprintf(output_file, "%c", *ptr);
        }
    }
    fprintf(output_file, "\",\n");
}

const char* rgsl_get_stage_enum(const char* stage) {
    size_t num_mappings = sizeof(STAGE_MAPPINGS) / sizeof(STAGE_MAPPINGS[0]);
    for (size_t i = 0; i < num_mappings; i++) {
        if (strcmp(stage, STAGE_MAPPINGS[i].extension) == 0) {
            return STAGE_MAPPINGS[i].stage;
        }
    }
    return "RGSL_UNKNOWN_STAGE";
}

bool rgsl_package_shaders(struct shader_data* shaders) {
    bool success = true;

    FILE *output_file;
    fopen_s(&output_file, rgsl_global_options.output_file, "w");
    if (output_file == NULL) {
        rgsl_printf_error("Failed to open output file for packaging: %s\n", rgsl_global_options.output_file);
        return false;
    }

    fprintf(output_file, "// Generated by RGSL Shader Packager\n\n");
    fprintf(output_file, "#include <stdint.h>\n\n");

    fprintf(output_file, 
        "enum rgsl_stage {\n"
        "    RGSL_VERTEX,\n"
        "    RGSL_FRAGMENT,\n"
        "    RGSL_COMPUTE,\n"
        "    RGSL_UNKNOWN_STAGE\n"
        "};\n"
        "\n"
        "struct rgsl_shader_blob {\n"
        "    const char *name;\n"
        "    enum rgsl_stage stage;\n"
        "    int version;\n"
        "    const char *profile;\n"
    );
    if (rgsl_global_options.action & RGSL_ACTION_COMPILE_SPIRV) {
        fprintf(output_file,
        "    const uint32_t *spirv_words;\n"
        "    size_t word_count;\n"
        );
    } else {
        fprintf(output_file,
        "    const char *glsl_code;\n"
        );
    }
    fprintf(output_file,
        "};\n\n"
    );

    if (rgsl_global_options.action & RGSL_ACTION_COMPILE_SPIRV) {
        for (size_t i = 0; shaders[i].code != NULL; i++) {
            fprintf(output_file, "static const uint32_t __rgsl__spirv_words_%zu[] = \n", i);
            write_embedded_spirv(output_file, (const uint32_t*)shaders[i].code, shaders[i].word_count);
        }
    }

    fprintf(output_file, "const struct rgsl_shader_blob rgsl_shaders[] = {\n");

    for (size_t i = 0; shaders[i].code != NULL; i++) {
        struct shader_data shader = shaders[i];
        const char* shader_code = shader.code;
        const size_t word_count = shader.word_count;
        
        fprintf(output_file, "\t{\n");

        fprintf(output_file, "\t\t\"shader_%s\",\n", shader.name);
        fprintf(output_file, "\t\t%s,\n", rgsl_get_stage_enum(shader.stage));
        fprintf(output_file, "\t\t%d,\n", shader.profile.version);
        fprintf(output_file, "\t\t\"%s\",\n", shader.profile.name);

        if (rgsl_global_options.action & RGSL_ACTION_COMPILE_SPIRV) {
            fprintf(output_file, "\t\t__rgsl__spirv_words_%zu,\n", i);
            fprintf(output_file, "\t\t%zu,\n", word_count);
        } else {
            write_embedded_glsl(output_file, shader_code);
        }
        fprintf(output_file, "\t},\n");
    }

    fprintf(output_file, "};\n");

    return success;
}